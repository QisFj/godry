// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates:
// - sets.go
// It can be invoked by running go generate
package main

import (
	"log"
	"strings"

	"github.com/QisFj/godry/gen"
)

func main() {
	types := gen.ParseFlagTypes()
	log.Printf("types: \n- '%s'\n", strings.Join(types, "'\n- '"))
	gen.Gen("sets", T, types)
}

const T = `// Code generated by go generate; DO NOT EDIT.
package set

<< range $t := .>>
type <<$t | Title>> map[<<$t>>]struct{}

func (set *<< $t | Title >>) Add(es ...<<$t>>) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set << $t | Title >>) List() []<<$t>> {
	l := make([]<<$t>>, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set << $t | Title >>) Contains(e <<$t>>) bool {
	_, contains := set[e]
	return contains
}


func (set << $t | Title >>) ContainsAny(es ...<<$t>>) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set << $t | Title >>) ContainsAll(es ...<<$t>>) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func << $t | Title >>Diff(set1, set2 << $t | Title >>) (both, only1, only2 << $t | Title >>) {
	both, only1, only2 = << $t | Title >>{}, << $t | Title >>{}, << $t | Title >>{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func << $t | Title >>Merge(set1, set2 << $t | Title >>) << $t | Title >> {
	set := << $t | Title >>{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}
<< end >>
`

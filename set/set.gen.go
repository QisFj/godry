// The following directive is necessary to make the package coherent:

//go:build ignore
// +build ignore

// This program generates:
// - sets.go
// It can be invoked by running go generate
package main

import (
	"log"
	"strings"

	"github.com/QisFj/godry/gen"
)

func main() {
	types := gen.ParseFlagTypes()
	log.Printf("types: \n- '%s'\n", strings.Join(types, "'\n- '"))
	gen.Gen("sets", T, types)
}

const T = `// Code generated by go generate; DO NOT EDIT.
package set

import (
	"encoding/json"
	"sort"
)

// MarshalOrder can change the order of the elements when marshaling.
// 1 for desc
// 2 for asc
// 0 or other value for no certain order
var MarshalOrder = 0
<< range $t := .>>
type <<$t | Title>> map[<<$t>>]struct{}

func (set *<< $t | Title >>) Add(es ...<<$t>>) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set << $t | Title >>) List() []<<$t>> {
	l := make([]<<$t>>, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set << $t | Title >>) Contains(e <<$t>>) bool {
	_, contains := set[e]
	return contains
}

func (set << $t | Title >>) ContainsAny(es ...<<$t>>) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set << $t | Title >>) ContainsAll(es ...<<$t>>) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func << $t | Title >>Diff(set1, set2 << $t | Title >>) (both, only1, only2 << $t | Title >>) {
	both, only1, only2 = << $t | Title >>{}, << $t | Title >>{}, << $t | Title >>{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func << $t | Title >>Merge(set1, set2 << $t | Title >>) << $t | Title >> {
	set := << $t | Title >>{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

func From<< $t | Title >>s(es ...<<$t>>) << $t | Title >> {
	set := << $t | Title >>{}
	set.Add(es...)
	return set
}

func (set << $t | Title >>) MarshalJSON() ([]byte, error) {
	if set == nil {
		return []byte("null"), nil
	}
	list := set.List()
	switch MarshalOrder {
	case 1:
		sort.Slice(list, func(i, j int) bool { return list[i] < list[j] }) // ensure return with certain order
	case 2: 
		sort.Slice(list, func(i, j int) bool { return list[i] > list[j] }) // ensure return with certain order
	}
	return json.Marshal(list)
}

func (set *<< $t | Title >>) UnmarshalJSON(data []byte) error {
	if len(data) == 4 && string(data) == "null" {
		(*set) = nil
		return nil
	}
	var l []<<$t>>
	if err := json.Unmarshal(data, &l); err != nil {
		return err
	}
	(*set) = From<< $t | Title >>s(l...)
	return nil
}
<< end >>
`

// Code generated by go generate; DO NOT EDIT.
package set

import (
	"encoding/json"
	"sort"
)

// MarshalOrder can change the order of the elements when marshaling.
// 1 for desc
// 2 for asc
// 0 or other value for no certain order
var MarshalOrder = 0

type String map[string]struct{}

func (set *String) Add(es ...string) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set String) List() []string {
	l := make([]string, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set String) Contains(e string) bool {
	_, contains := set[e]
	return contains
}

func (set String) ContainsAny(es ...string) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set String) ContainsAll(es ...string) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func StringDiff(set1, set2 String) (both, only1, only2 String) {
	both, only1, only2 = String{}, String{}, String{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func StringMerge(set1, set2 String) String {
	set := String{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

func FromStrings(es ...string) String {
	set := String{}
	set.Add(es...)
	return set
}

func (set String) MarshalJSON() ([]byte, error) {
	if set == nil {
		return []byte("null"), nil
	}
	list := set.List()
	switch MarshalOrder {
	case 1:
		sort.Slice(list, func(i, j int) bool { return list[i] < list[j] }) // ensure return with certain order
	case 2:
		sort.Slice(list, func(i, j int) bool { return list[i] > list[j] }) // ensure return with certain order
	}
	return json.Marshal(list)
}

func (set *String) UnmarshalJSON(data []byte) error {
	if len(data) == 4 && string(data) == "null" {
		(*set) = nil
		return nil
	}
	var l []string
	if err := json.Unmarshal(data, &l); err != nil {
		return err
	}
	(*set) = FromStrings(l...)
	return nil
}

type Int map[int]struct{}

func (set *Int) Add(es ...int) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set Int) List() []int {
	l := make([]int, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set Int) Contains(e int) bool {
	_, contains := set[e]
	return contains
}

func (set Int) ContainsAny(es ...int) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set Int) ContainsAll(es ...int) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func IntDiff(set1, set2 Int) (both, only1, only2 Int) {
	both, only1, only2 = Int{}, Int{}, Int{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func IntMerge(set1, set2 Int) Int {
	set := Int{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

func FromInts(es ...int) Int {
	set := Int{}
	set.Add(es...)
	return set
}

func (set Int) MarshalJSON() ([]byte, error) {
	if set == nil {
		return []byte("null"), nil
	}
	list := set.List()
	switch MarshalOrder {
	case 1:
		sort.Slice(list, func(i, j int) bool { return list[i] < list[j] }) // ensure return with certain order
	case 2:
		sort.Slice(list, func(i, j int) bool { return list[i] > list[j] }) // ensure return with certain order
	}
	return json.Marshal(list)
}

func (set *Int) UnmarshalJSON(data []byte) error {
	if len(data) == 4 && string(data) == "null" {
		(*set) = nil
		return nil
	}
	var l []int
	if err := json.Unmarshal(data, &l); err != nil {
		return err
	}
	(*set) = FromInts(l...)
	return nil
}

type Uint map[uint]struct{}

func (set *Uint) Add(es ...uint) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set Uint) List() []uint {
	l := make([]uint, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set Uint) Contains(e uint) bool {
	_, contains := set[e]
	return contains
}

func (set Uint) ContainsAny(es ...uint) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set Uint) ContainsAll(es ...uint) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func UintDiff(set1, set2 Uint) (both, only1, only2 Uint) {
	both, only1, only2 = Uint{}, Uint{}, Uint{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func UintMerge(set1, set2 Uint) Uint {
	set := Uint{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

func FromUints(es ...uint) Uint {
	set := Uint{}
	set.Add(es...)
	return set
}

func (set Uint) MarshalJSON() ([]byte, error) {
	if set == nil {
		return []byte("null"), nil
	}
	list := set.List()
	switch MarshalOrder {
	case 1:
		sort.Slice(list, func(i, j int) bool { return list[i] < list[j] }) // ensure return with certain order
	case 2:
		sort.Slice(list, func(i, j int) bool { return list[i] > list[j] }) // ensure return with certain order
	}
	return json.Marshal(list)
}

func (set *Uint) UnmarshalJSON(data []byte) error {
	if len(data) == 4 && string(data) == "null" {
		(*set) = nil
		return nil
	}
	var l []uint
	if err := json.Unmarshal(data, &l); err != nil {
		return err
	}
	(*set) = FromUints(l...)
	return nil
}

// Code generated by go generate; DO NOT EDIT.
package set

type String map[string]struct{}

func (set *String) Add(es ...string) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set String) List() []string {
	l := make([]string, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set String) Contains(e string) bool {
	_, contains := set[e]
	return contains
}

func (set String) ContainsAny(es ...string) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set String) ContainsAll(es ...string) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func StringDiff(set1, set2 String) (both, only1, only2 String) {
	both, only1, only2 = String{}, String{}, String{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func StringMerge(set1, set2 String) String {
	set := String{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

type Int map[int]struct{}

func (set *Int) Add(es ...int) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set Int) List() []int {
	l := make([]int, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set Int) Contains(e int) bool {
	_, contains := set[e]
	return contains
}

func (set Int) ContainsAny(es ...int) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set Int) ContainsAll(es ...int) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func IntDiff(set1, set2 Int) (both, only1, only2 Int) {
	both, only1, only2 = Int{}, Int{}, Int{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func IntMerge(set1, set2 Int) Int {
	set := Int{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}

type Uint map[uint]struct{}

func (set *Uint) Add(es ...uint) {
	for _, e := range es {
		(*set)[e] = struct{}{}
	}
}

func (set Uint) List() []uint {
	l := make([]uint, 0, len(set))
	for e := range set {
		l = append(l, e)
	}
	return l
}

func (set Uint) Contains(e uint) bool {
	_, contains := set[e]
	return contains
}

func (set Uint) ContainsAny(es ...uint) bool {
	for _, e := range es {
		if _, contains := set[e]; contains {
			return true
		}
	}
	return false
}

func (set Uint) ContainsAll(es ...uint) bool {
	for _, e := range es {
		if _, contains := set[e]; !contains {
			return false
		}
	}
	return true
}

func UintDiff(set1, set2 Uint) (both, only1, only2 Uint) {
	both, only1, only2 = Uint{}, Uint{}, Uint{}
	for v := range set1 {
		if set2.Contains(v) {
			both.Add(v)
		} else {
			only1.Add(v)
		}
	}
	for v := range set2 {
		if set1.Contains(v) {
			both.Add(v)
		} else {
			only2.Add(v)
		}
	}
	return
}

func UintMerge(set1, set2 Uint) Uint {
	set := Uint{}
	set.Add(set1.List()...)
	set.Add(set2.List()...)
	return set
}
